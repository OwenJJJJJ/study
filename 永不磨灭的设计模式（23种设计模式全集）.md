# 永不磨灭的设计模式（23种设计模式合集）

# 概述

设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

# 七大基本原则

- 单一职责原则
- 里氏替换原则
- 依赖倒置原则
- 开闭原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则

详细讲解：[七大原则](https://blog.csdn.net/qq_46307070/article/details/130813231)



# 23种设计模式

我们将23种设计模式分为创建型模式、结构型模式和行为模式。

- 创建型模式：提供创建对象的机制，能够提升已有代码的灵活性和可复用性
- 结构型模式：介绍如何将对象和类组成比较大的结构，并同时保持结构的灵活和高效
- 行为模式：负责对象间的搞笑沟通和职责委培

![image-20230605174639361](https://owenguo.com/img/202306051746627.png)



<h1 align = "center"> 创建型模式 </h1>

### 1、单例模式

单例模式就是对象永远只会生成同一个对象，不论如何创建都返回同一个对象。是最简单的设计模式。

**详细讲解**：[设计模式 - 单例模式](https://blog.csdn.net/qq_46307070/article/details/130836477)

### 2、工厂(方法)模式

> 简单工厂模式：
>
> 我们需要了解简单工厂模式。简单工厂模式就好比我们在家吃饭，只需要告诉妈妈想吃什么即可，不需要去向具体的制作过程。
>
> 放到我们的代码中就是有一个工厂类，它可以创建一对象，我们只需要告诉它我们想要什么对象即可。

**工厂(方法)模式就好比我们去外面吃饭，不同的店提供不同的食品，我们挑选自己想吃的食品进去下单即可。**



**为什么要使用工厂(方法)模式：**

因为如果我们要扩展可以创建不同的对象，那简单工厂就是需要去修改工厂类的源码的，这违反了开闭原则。

所以就将工厂设置为了抽象类，不同的工厂继承抽象工厂类即可生成不同的产品，想要什么样的产品就使用什么工厂类即可。

这样在扩展的时候只需要创建不同的工厂类即可。

**详细讲解**：[设计模式 - 工厂(方法)模式](https://blog.csdn.net/qq_46307070/article/details/130854784)

### 3、抽象工厂模式

抽象工厂模式可以简单理解为一个大的食堂，这个食堂有各种各样的食品，我们需要要下单即可送到我们身边。

**与工厂(方法)模式的区别：**

工厂(方法)模式中的工厂还是只能生成同一类的产品，而抽象工厂模式则可以实现不同种类的产品。如果抽象工厂模式也只生成一种品类的产品，那将退化为抽象(工厂)方法

**详细讲解**：[设计模式 - 抽象工厂模式](https://blog.csdn.net/qq_46307070/article/details/130854784?spm=1001.2014.3001.5502)

### 4、原型模式

原型模式理解为克隆，即创建重复的对象，但又可以保证性能。

实现`Cloneable`接口并重写`clone()`方法即可实现克隆

关于浅克隆和深克隆

**详细讲解**：[设计模式 - 原型模式](https://blog.csdn.net/qq_46307070/article/details/130875736)

### 5、建造者模式

对于复杂对象，我们是不可能一下将这个对象创建出来的，我们需要将这个对象进行拆解，然后按步骤来创建这个复杂的对象，实现了创建复杂对象的灵活性和可读性。

例如生产汽车，不可能是一下就将汽车创建出来`new Car("发动机","轮胎","...")`，而是将不同的零件按步骤添加到车辆中`car.set("发动机") ......`

**详细讲解**：[设计模式 - 建造者模式](https://blog.csdn.net/qq_46307070/article/details/130876818)



<h1 align = "center">结构型模式</h1>

### 6、适配器模式

适配器模式可以简单理解为手机充电器，手机充电是不能直接使用220V交流电的，所以需要使用充电器来将电压转为5V才能充电。

根据单一职责原则，一个类只负责一种功能，所以交流电和手机使用的电压对应两个不同的类，这样就可以增加一个适配器类来将两个类进行适配，这就是适配器模式。

**详细讲解**：[设计模式 - 适配器模式](https://blog.csdn.net/qq_46307070/article/details/130915304)

### 7、桥接模式

桥接模式是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

将抽象部分与实现部分分离，使它们都可以独立的变化。

**详细讲解**：[设计模式 - 桥接模式](https://blog.csdn.net/qq_46307070/article/details/130916320)

### 8、组和模式

组和模式可以理解为一个树形结构中的各个元素都是结构相同的对象，我们来将这些元素抽象为一个抽象类，自己组和自己。

这样就不需要每一个层次都创建自己的结构，使用同一个结构即可。

**详细解析**：[设计模式 - 组和模式](https://blog.csdn.net/qq_46307070/article/details/130905233)

### 9、装饰器模式

装饰器模式就是允许一个现有的对象添加功能，同时又不改变其结构。

我们可以想想去咖啡店点咖啡的时候，点了咖啡还可以加许多配料，设计这样的结构并且使代码符合开闭原则。

**详细讲解**：[设计模式 - 装饰器模式](https://blog.csdn.net/qq_46307070/article/details/130907157)

### 10、外观模式

外观模式隐藏了系统的复杂性，并向客户端提供一个可以访问的接口。

例如我们在家里看电影，我们要做很多准备，但是如果我们有智能家庭影院的话我们只需要点几个按钮就可以了。智能家庭影院屏蔽了一些繁琐的细节，提供给我们简单明了的步骤。

**详细讲解**：[设计模式 - 外观模式](https://blog.csdn.net/qq_46307070/article/details/130937600)

### 11、享元模式

享元模式即共享元素，如果一个需求基本都是相同的，那就将这个系统可变的需求独立出来，后面使用时只需要改变不同的位置即可，共同的地方是公用的。

享元模式主要用于减少创建对象的数量，以减少内存占用和提高性能。

**详细讲解**：[设计模式 - 享元模式](https://blog.csdn.net/qq_46307070/article/details/130936530)

### 12、代理模式

代理模式主要有三种实现：静态代理、动态代理合Cglib代理。

**详细讲解**：[设计模式 - 代理模式](https://blog.csdn.net/qq_46307070/article/details/130958855)



<h1 align = "center">行为模式</h1>



### 13、责任链模式

为请求创建一个链式结构，链中的每一个节点依次对请求进行处理。知道满足结束条件即可。

**详细讲解**：[设计模式-责任链模式](https://blog.csdn.net/qq_46307070/article/details/131029477)

### 14、命令模式

命令模式就是将我们需要执行的动作制作为命令，发送者只需要发送命令，具体命令怎么执行和谁来执行都不需要关注。

例如古代将军发号施令，它是不需要关注具体的执行过程的。

**详细讲解**：[设计模式 - 命令模式](https://blog.csdn.net/qq_46307070/article/details/130990223)

### 15、迭代器模式

迭代器模式就是将容器遍历的行为和容器分离开来，例如树的结构有好几种遍历方式，我们容器只关注树的存储结构，迭代器只关注容器的遍历方法，这样组和起来即可满足开闭原则。

**详细讲解**：[设计模式 - 迭代器模式](https://blog.csdn.net/qq_46307070/article/details/130996523)

### 16、中介者模式

中介者模式是用来降低多个对象和类之间的通信复杂性。将复杂的逻辑都维护到一个中介类中，其他类之间可以实现松耦合，使代码易于维护。

**详细讲解**：[设计模式 - 中介者模式](https://blog.csdn.net/qq_46307070/article/details/131020758)

### 17、备忘录模式

备忘录模式就是保存某一时刻某个对象的重要属性，以便在适当的时候恢复。

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

**详细讲解**：[设计模式 - 备忘录模式](https://blog.csdn.net/qq_46307070/article/details/131024792)

### 18、观察者模式

观察者模式就是被观察者实现一个存放观察者的集合，当发送变化时及时将信息同步到观察者。

**详细讲解**：[设计模式 - 观察者模式](https://blog.csdn.net/qq_46307070/article/details/130996160)

### 19、状态模式

学漏一个，后续补充

### 20、策略模式

一个类的行为或其算法可以在运行时更改，类中组和一个策略接口，随策略的改变，类产生的结果不同。

**详细讲解**：[设计模式 - 策略模式](https://blog.csdn.net/qq_46307070/article/details/131025767)

### 21、模板方法模式

在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**详细讲解**：[设计模式 - 模板方法模式](https://blog.csdn.net/qq_46307070/article/details/130957620)

### 22、访问者模式

访问者模式就是将数据结构和数据操作分离，可以动态的变化数据操作。这个模式解决了稳定的数据结构和易变的操作耦合问题。

**详细讲解**：[设计模式 - 访问者模式](https://blog.csdn.net/qq_46307070/article/details/130977564)

### 23、解释器模式

解释器模式就是给我们一个特定的规则，我们来创建解释器，后续依据这解释器就可以得到结果。

解释器模式就是一个框架，按这个框架我们就能开发自己的解释器。

**详细讲解**：[设计模式 - 解释器模式](https://blog.csdn.net/qq_46307070/article/details/131023404)

# 总结

本篇为设计模式的汇总，详细的讲解可以点击对应的连接来学习。

后续我将会继续完善这些文章，将自己在工作中的体会输出到专栏中

你可以先点赞收藏起来，这样就不怕找不到这篇文章啦。

# 源码

GitHub源码地址：[design-patterns](https://github.com/OwenGuoJ/design-patterns)

目前仓库中拥有23种设计模式的代码示例，后续将会增加更多实际问题中关于设计模式的代码Demo
